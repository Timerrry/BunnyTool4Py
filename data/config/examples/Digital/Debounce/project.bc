{"author":"timmery","board":"ArduinoUNO","createdAt":1531281096,"files":[{"content":"from mpython import *\n\nHIGH = 1  # 高电平\nLOW = 0  # 低电平\n\nbuttonPin = 2    # 设置按钮引脚号\nledPin = 13      # 设置LED引脚号\n\nledState = HIGH         # 输出引脚的当前状态\nbuttonState = 0            # 输入引脚的电流读数\nlastButtonState = LOW   # 输入引脚的先前读数\n\nlastDebounceTime = 0  # 最后一次切换输出引脚\ndebounceDelay = 50    # 去抖，如果输出闪烁则增加此变量\n\npBtn = MPythonPin(buttonPin, PinMode.IN)\npLed = MPythonPin(ledPin, PinMode.OUT)\n\n# 设置初始LED状态\npLed.write_digital(ledState)\n\nwhile True:\n    # 将切换状态读入局部变量\n    reading = pBtn.read_digital()\n    # 检查你是否只按了按钮\n    #（即输入从低到高），你已经等了足够长的时间\n    # 自上次按下以忽略任何噪音：\n    \n    # 如果开关由于噪音或按压而改变：\n    if reading != lastButtonState:\n        # 重置去抖动计时器\n        lastDebounceTime = time.ticks_cpu()\n    \n    if (time.ticks_cpu() - lastDebounceTime) > debounceDelay:\n    # 无论阅读是什么，它存在的时间都长于去抖\n    # 延迟，所以把它当作实际的当前状态：\n\n        # 如果按钮状态已更改：\n        if reading != buttonState:\n            buttonState = reading\n\n        # 如果新按钮状态为HIGH，则仅切换LED\n        if (buttonState == HIGH):\n            ledState = int(not ledState)\n    \n    # 设置LED：\n    pLed.write_digital(ledState)\n\n    # 保存阅读。 下次循环时，它将是lastButtonState：\n    lastButtonState = reading","language":"cpp","main":false,"name":"Debounce.py"}],"index":0,"name":"Debounce","updatedAt":1556623490}
